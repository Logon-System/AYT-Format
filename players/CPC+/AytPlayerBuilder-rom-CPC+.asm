;;============================================================================================================================================ 
;;              _____  __     _____  _____  _____    _____  _____  _____  _____    _____  __     _____  __ __  _____  _____
;;             |  |  ||  |   |_   _|| __  ||  _  |  |   __||  _  ||   __||_   _|  |  _  ||  |   |  _  ||  |  ||   __|| __  |
;;             |  |  ||  |__   | |  |    -||     |  |   __||     ||__   |  | |    |   __||  |__ |     ||_   _||   __||    -|
;;             |_____||_____|  |_|  |__|__||__|__|  |__|   |__|__||_____|  |_|    |__|   |_____||__|__|  |_|  |_____||__|__|
;;
;;                                                                                            ,,
;;                                 db      `YMM'   `MM'    MMP""MM""YMM                      *MM
;;                                ;MM:       VMA   ,V      P'   MM   `7                       MM
;;                               ,V^MM.       VMA ,V            MM      `7MM  `7MM  `7Mb,od8  MM,dMMb.   ,pW"Wq.
;;                              ,M  `MM        VMMP             MM        MM    MM    MM' "'  MM    `Mb 6W'   `Wb
;;                              AbmmmqMA        MM              MM        MM    MM    MM      MM     M8 8M     M8
;;                             A'     VML       MM              MM        MM    MM    MM      MM.   ,M9 YA.   ,A9
;;                           .AMA.   .AMMA.   .JMML.          .JMML.      `Mbod"YML..JMML.    P^YbmdP'   `Ybmd9'
;;
;;
;;============================================================================================================================================
;; 
;;                                                              _ (`-.         ('-.
;;                                                             ( (OO  )       ( OO ).-.
;;                                            ,----.          _.`     \       / . --. /
;;                                           '  .-./-')      (__...--''       | \-.  \
;;                                           |  |_( O- )      |  /  | |     .-'-'  |  |
;;                                           |  | .--, \      |  |_.' |      \| |_.'  |
;;                                          (|  | '. (_/      |  .___.'       |  .-.  |
;;                                           |  '--'  |  .-.  |  |      .-.   |  | |  | .-.
;;                                            `------'   `-'  `--'      `-'   `--' `--' `-'
;;
;;
;;                                                         .-') _      .-')                   .-')     .-') _       ('-.    _   .-')
;;                                                        ( OO ) )    ( OO ).                ( OO ).  (  OO) )    _(  OO)  ( '.( OO )_
;;   ,--.       .-'),-----.   ,----.      .-'),-----. ,--./ ,--,'    (_)---\_)   ,--.   ,--.(_)---\_) /     '._  (,------.  ,--.   ,--.)
;;   |  |.-')  ( OO'  .-.  ' '  .-./-')  ( OO'  .-.  '|   \ |  |\    /    _ |     \  `.'  / /    _ |  |'--...__)  |  .---'  |   `.'   |
;;   |  | OO ) /   |  | |  | |  |_( O- ) /   |  | |  ||    \|  | )   \  :` `.   .-')     /  \  :` `.  '--.  .--'  |  |      |         |
;;   |  |`-' | \_) |  |\|  | |  | .--, \ \_) |  |\|  ||  .     |/     '..`''.) (OO  \   /    '..`''.)    |  |    (|  '--.   |  |'.'|  |
;;   |  '---.'   \ |  | |  |(|  | '. (_/   \ |  | |  ||  |\    |     .-._)   \  |   /  /\_  .-._)   \    |  |     |  .--'   |  |   |  |
;;   |      |     `'  '-'  ' |  '--'  |     `'  '-'  '|  | \   |     \       /  `-./  /.__) \       /    |  |     |  `---.  |  |   |  |
;;   `------'       `-----'   `------'        `-----' `--'  `--'      `-----'     `--'       `-----'     `--'     `------'  `--'   `--'
;;
;;============================================================================================================================================
;; ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION
;; ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION ROM VERSION
;;============================================================================================================================================
;; Mega Fucking Ultra Fucking Fast Player Fucking v3.1 for CPC+ :-)
;; AYT Player generated by AYT Builder
;; CONSTANT CPU Execution, NO buffer, NO unpacking, LOOP everywhere, NO Address limitations,  NO ROM Flipping, TINY Size, INIT included
;;
;; 30th October 2025
;; Credits 
;; Delphi original AYT SeqMarker   
;; Web YM to AYT converter       : Tronic (GPA)
;; C Unix/Windows AYT converter  : Siko (Logon System) (Stephane Sikora @ https://www.sikorama.fr)
;; CPC+ AYT Z80A player/Builder  : Longshot (Logon System) (Serge Querne @ logon.system@free.fr)
;;
;; 25.11.2025 : New version "Player in Rom"
;;============================================================================================================================================
;; Performance at low and high limits depending on assembly options
;;--------------------------------------------------------------------------
;; Option PlayerAccessByJP equ  0	; Method "call player"
;; Worst configuration
;; Asic Page "in" is on, Asic Page "out" is off, File is in bad area
;;     10 registers : 220 nops (3.43 raster lines) / Player size : 230 bytes
;;     11 registers : 232 nops (3.62 raster lines) / Player size : 236 bytes
;;     12 registers : 244 nops (3.81 raster lines) / Player size : 242 bytes
;;     13 registers : 256 nops (4.00 raster lines) / Player size : 248 bytes
;;     14 registers : 268 nops (4.18 raster lines) / Player size : 254 bytes
;;     Size of Ayt_Builder : 533 bytes
;; Option PlayerAccessByJP  equ 1	; Method "jp player" 
;; Better Configuration
;; Asic Page "in" is on, Asic Page "out" is on, File AYT is not in Asic Page
;;     10 registers : 186 nops (2.90 raster lines) / Player size : 210 bytes
;;     11 registers : 198 nops (3.09 raster lines) / Player size : 216 bytes
;;     12 registers : 210 nops (3.28 raster lines) / Player size : 222 bytes
;;     13 registers : 222 nops (3.47 raster lines) / Player size : 228 bytes 
;;     14 registers : 234 nops (3.65 raster lines) / Player size : 234 bytes 
;;     Size of Ayt_Builder : 522 bytes
;;
;;--------------------------------------------------------------------------
;; Init AY Reg routine
;;---------------------------
;; The player's built-in initialization routine must be called once before the player's period call. 
;; Its role is to initialize the variables in RAM and the DMA list, and possibly update inactive AY registers.
;;--------------------------------------------------------------------------
;; Notes :
;; Ayt Builder can be removed once music player built & music data initialized.
;; (i.e. you can use the player and the data file completely independently of the Ayt builder)
;; Performance is given for 10 to 14 non-active registers, but the player can handle a variable number of active registers. 
;; For example, if a song uses only two channels and nine active registers, then performance will be better.
;;============================================================================================================================================
;; Technical information about AYT Format
;; --------------------------------------
;; Ayt_Start
;; struct AYT_Header
;; { 
;;  uint8_t Ayt_Version      	; version aaaabbbb >> a.b
;;  uint16_t Ayt_ActiveRegs     ; active reg (bit 15:reg 0...bit 2:reg 13) 1=active 0:inactive
;;  uint8_t Ayt_PatternSize  	; Pattern size 1..255
;;  uint16_t Ayt_FirstSeqMarker ; Offset from Ayt_Start for Seq Ptr on patterns
;;  uint16_t Ayt_LoopSeqMarker 	; Offset from Ayt_Start for Loop Seq Ptr 
;;  uint16_t Ayt_ListInit	; Offset from Ayt_Start for Init of ay reg (*)
;;  uint16_t Ayt_NbPatternPtr  	; Nb of pattern ptr seq for music (NbSeq x NbReg)
;;  uint8_t  Ayt_PlatformFreq	; Platform (b0..4) & Frequency (b5..7) (see table) (**)
;;  uint8_t  Ayt_Reserved	; Reserved for future version (=0)
;; }
;; Start of Patterns
;;
;; (*)
;; struct Ay_Init 
;; {
;;  uint8_t Ayt_Reg		; No reg (0 to 13) 
;;  uint8_t Ayt_Val
;; } x N register to initialize
;; Last byte=#ff
;;
;; (**) 
;; bit 4..0 00000 AMSTRAD CPC (1 000 000 hz)
;;          00001 ORIC        (1 000 000 hz)
;;          00010 ZXUNO       (1 750 000 hz)
;;          00011 PENTAGON    (1 750 000 hz)
;;          00100 TIMEXTS2068 (1 764 000 hz)
;;          00101 ZX128       (1 773 450 hz)
;;          00110 MSX         (1 789 772 hz)
;;          00111 ATARI ST    (2 000 000 hz)
;;          01000 VG5000      (1 000 000 hz) (Ext card VG5210)
;;          11111 UNKNOWN  
;;
;; bit 7..5 000 50 hz
;;          001 25 hz
;;          010 60 hz
;;          011 30 hz
;;          111 UNKNOWN
;;
;; Start of Sequences of ptr on Pattern by Reg  
;;
;; A "Last Sequence" is generated after the last seq of AYT file.
;; Last sequence consists of Ayt_NbRegs pointers on 3 special 'pattern' bytes
;; This is done :
;; - to mute the music at end of play (some ym music don't do the job sometimes)
;; - to give end music status to player
;; Detail of the last sequence : Ayt_NbReg x WordPointer + 3 'pattern' bytes
;;               7 identical ptr on pattern 1 b with 0
;;               1 ptr for r7 on pattern 1b with 3f (mute ay)
;;               4/5 ptr for r8-r12/r13 on pattern 1 b with 0
;;		 1 ptr for r13 on pattern 1b 
;;			bit 7 >> if 1 : R13 not played or Music End
;;			bit 6 >> If 0 : If bit 7==1 then Music End Else r13 is not updated while playing std pattern 
;;                      bit 5 to 0 >> reserved (always 1)
;; i.e. this sequence points to these values (with Nbregs= 14) : 0,0,0,0,0,0,0,3F,0,0,0,0,0,BF
;;============================================================================================================================================
;;
;;============================================================================================================================================
;; https://www.youtube.com/watch?v=pFptt7Cargc&list=RD3zp_71AmBCE&index=30
;;============================================================================================================================================
;;
;; RESTRICTIONS !! READ CAREFULLY !!
;;
;;============================================================================================================================================
;;
;; Input parameters
;;
;; Player address:
;;----------------
;; The contents of the DE register represent the address where the Ayt_Builder function creates the player. 
;; Area between 0x4000 and 0x7FFF cannot be used by the player. 
;; But in principle, it is not possible with the native hardware of a CPC+ to connect a ROM between &4000 and &7FFF with the ASIC page active.
;;
;; The code calling the player must have previously unlocked the ASIC.
;; Asic_Unlock             
;; 		ld de,#533e		; interleave key 32 bits 
;;		ld hl,#849		; interleave key (#841 to lock)
;;		ld a,#ff
;;		ld bc,#bcef		; crtc input io address and 1st nibbles
;;		out (c),a		; RQ00 <>0
;;		out (c),0		; defb #ed,#71	; Send 00 (out (c),0
;; Asic_Unlock_Loop:
;;		out (c),a		; Send 2 nibbles
;;		xor h			; Put bit 12 of the key in the bit 4 of A for high nibble
;;		and c			; erase bit 4 to put key bit instead
;;		xor h
;;		adc hl,hl		; Extract left incoming bit of high nibble of interleave key
;;		ret z			; exit when key is empty (extra value sent to io address)
;;		ex de,hl		; Switch the interleave key (add hl,hl is good for you) 
;;		rra			; Bit 7 high nibble=Cf and rotate the complete byte
;;		add hl,hl		; Extract left incoming bit of low nibble of interleave key 
;;		jr Asic_Unlock_Loop	; Send at last 18 values to crtc input io address
;;
;; Asic Io Page parameter :
;;-------------------------
;; The BC register contains two important pieces of information that indicate the state of the io asic page at the input of the "player" 
;; and the expected state of this page at the output of the "player".
;; * If B contains 0, then the Asic io page must be connected before calling the player; otherwise, it must not be connected.
;; * If C contains 0, then the Asic io page will be disconnected when the player exits; otherwise, it will be connected.
;; Ayt_Builder checks whether the AYT file is located (or not) in the Asic io page space. 
;; If it is, and the io page is defined in register B as connected to the player input, then the player will disconnect the io page to be able 
;; to read the file and update the DMA list. It will reconnect the io page to be able to manage the DMA control and will restore the io page 
;; according to the option indicated in register C.
;; If the file is not present in the io page space and the page is defined as connected (via register B), then the player does not need to 
;; disconnect the io page at the entry point. 
;; In this situation, the player will also not need to connect the Asic page to update the DMA controls. 
;; If the user has defined in register C that the io page must remain connected, then the player will not need to do so (since it is already connected). 
;; This configuration allows to "gain" 20 nops compared to the worst case scenario. (8 possible cases).
;; For more information, see the GitHub page on this topic:
;; https://github.com/Logon-System/AYT-Format/tree/main/players/CPC%2B
;;
;; Ram Buffer for variables :
;; --------------------------
;; The IY register must contain the address of a 38-byte buffer initialized to 0 (or 36 bytes if the PlayerAccesssByJp option is set to 1). 
;; This buffer contains the RAM variables that allow the player to function, as well as the DMA list required by the ASIC to send data to the AY register.
;; Since this version of the player is designed to operate in ROM, the address of this buffer must, at most, 
;; - start 7 bytes before the ROM's starting address (because the DMA list only needs to be written by the player) 
;; - not start within the space of a ROM.
;; Example :
;; - if your ROM is located between &C000 and &FFFF, then the maximum address for declaring the buffer is &C000-7=&BFF9.
;; - if your ROM is located between &0000 and &3FFF, then the first possible address for declaring the buffer is &4000.
;;
;;============================================================================================================================================
;;----------------------------------------------------------------------------------------------------------------------------------------------
;; Compilation options
;; There are additional assembly options in Ayt_Builder besides PlayerAccessByJP to take into account specific management features to CPC+.
;;----------------------------------------------------------------------------------------------------------------------------------------------
;;
;; PlayerAccessByJP option
;;
;; In most situations, the player can be called with the Z80A "call" instruction. 
;; The player uses the stack as a fast data pointer. 
;; It therefore saves the SP register and returns it when it finishes its work.
;; However, in a few exceptional situations, you might need to modify SP in your main code (to also use it as a fast pointer), 
;; and it would therefore not be useful for the player to waste time saving it. 
;; This, however, requires calling the player differently. 
;; The "PlayerAccessByJP" compile option, when set to 1, allows you to assemble "Ayt_Builder" to handle access to the player via the Z80A "JP" instruction. 
;; It is then necessary to specify the return address in the input parameters of "Ayt_Builder" (in the HL register). 
;; Access to the player is then done with a "JP Player" instead of a "CALL Player", and the player will then return to your main program with a JP on the 
;; address you provided in HL to the "Ayt_builder".
;; In terms of technical figures, this option allows you to reduce the size of the built player by 5 bytes, and to save 11 nops of CPU 
;; (since the SP backup is no longer ensured) 
;; Also I draw your attention to the following point: this call method implies determining in advance the return address of the "player". 
;; In development, if the return address is a label that varies, this forces the presence of the Ayt_Builder in memory at each compilation.
;;
;;
PlayerAccessByJP	equ 1		; If set to 1, requires you to take into account that SP has been wildly modified
;;
;;----------------------------------------------------------------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------------------------------------------------------------
;;
;; PlayerDMAUsed_SAR
;; PlayerDMAUsed_DCSRMask
;;
;; If your main program does not use the CPC+'s DMA functions, these two parameters do not apply to you. 
;; The CPC+ has three DMAs, and the player only needs one of them. 
;; The player does not change the operating state of the other two DMA channels.
;; By default, DMA channel 0 is set, but it is possible to change the DMA channel used if your main program uses DMA 0 for other purposes.
;; Here are the parameters according to the DMA channel associated with the player:
;; For DMA channel 0 (default)
;; PlayerDMAUsed_SAR      equ AYT_Asic_SAR0   ; Ptr in Asic Page on DMA List played
;; PlayerDMAUsed_DCSRMask equ AYT_Asic_DCSRM0 ; Mask for DMA activation
;; For DMA channel 1
;; PlayerDMAUsed_SAR      equ AYT_Asic_SAR1   ; Ptr in Asic Page on DMA List played
;; PlayerDMAUsed_DCSRMask equ AYT_Asic_DCSRM1 ; Mask for DMA activation
;; For DMA channel 2
;; PlayerDMAUsed_SAR      equ AYT_Asic_SAR2 ; Ptr in Asic Page on DMA List played
;; PlayerDMAUsed_DCSRMask equ AYT_Asic_DCSRM2 ; Mask for DMA activation
;; 
PlayerDMAUsed_SAR	equ AYT_Asic_SAR0	; Ptr in Asic Page on DMA List played
PlayerDMAUsed_DCSRMask	equ AYT_Asic_DCSRM0	; Mask for DMA activation 
;;
;;----------------------------------------------------------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------------------------------------------------------
AYT_OFS_Version		equ 0	;; Not yet used (hey it's the 1st version)
AYT_OFS_ActiveRegs	equ 1	;; active reg (bit 0:reg 0...bit 13:reg 13) 1=active (only r12 off is managed in v1)
AYT_OFS_PatternSize	equ 3	;; Pattern size in bytes from 1 to 255
AYT_OFS_FirstSeq	equ 4	;; Offset on first Seq Ptr for start
AYT_OFS_LoopSeq		equ 6	;; Offset on Seq Ptr for loop
AYT_OFS_ListInit	equ 8	;; Offset on Ay Init List
AYT_OFS_NbPatternPtr	equ 10	;; Nb of pattern ptr seq for music (NbSeq x NbReg)
AYT_OFS_PlatformFreq	equ 12  ;; Platform & Freq of play (see table)
AYT_OFS_Reserved	equ 13	;; Rhaaaaaaa
AYT_SIZE_HEADER		equ 14	;; Header size to find first pattern
;;
AYT_Asic_DCSR		equ #6c0f
AYT_Asic_SAR0		equ #6c00
AYT_Asic_SAR1		equ #6c04
AYT_Asic_SAR2		equ #6c08
AYT_Asic_DCSRM0		equ %00000001
AYT_Asic_DCSRM1		equ %00000010
AYT_Asic_DCSRM2		equ %00000100

AYT_AsicPage_On	 	equ #b8
AYT_AsicPage_Off 	equ #a0
;;
OFS_B3_Jrel1		equ Ayt_B3ToB5_Jr1-Ayt_Player_B3_Start
OFS_B3_Jrel2		equ Ayt_B3ToB5_Jr2-Ayt_Player_B3_Start
OFS_B3_Jrel3		equ Ayt_B3ToB5_Jr3-Ayt_Player_B3_Start

OFS_B5_Jrel1		equ Ayt_B5ToB3_Jr1-Ayt_Player_B5_Start
OFS_B5_Jrel2		equ Ayt_B5ToB3_Jr2-Ayt_Player_B5_Start
OFS_B5_Jrel3		equ Ayt_B5ToB3_Jr3-Ayt_Player_B5_Start

AYT_B2_SIZE		equ Ayt_Player_B2_End-Ayt_Player_B2_Start	
AYT_B3_SIZE		equ Ayt_Player_B3_End-Ayt_Player_B3_Start
AYT_B4_SIZE		equ Ayt_Player_B4_End-Ayt_Player_B4_Start

_AYT_BUILDER_SIZE	equ AYT_Builder_End-AYT_Builder_Start
;-----------------------------------------------------------------------------------------------------------------------------------------------
;;
;;**********************************************************************************************************************************************
;; Ayt Builder
;;
;;	in :	ix=address AYT file
;;              iy=address of RAM Buffer (38 bytes / 36 bytes if PlayerAccessByJP==0)
;;		de=address where Player is created (see restrictions)
;;		bc=iioo	>> io page asic state in/out (00:off / 11:on)
;;		a=nbloop expected
;;		hl(optional)=return address of player (only if Builder is compiled with PlayerAccessByJP equ 1)
;;	out : 
;;              hl=ptr on the init routine to call 1 time before to use player address.
;;		de=ptr on the first free byte after the player 
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
AYT_Builder_Start
		di
	if PlayerAccessByJP
			ld (Ayt_ExitPtr01),hl		; Set Main code return address
	endif
		ld (Ayt_MusicCntValue),a	; Nb of loop for music
		ld a,(ix+AYT_OFS_PatternSize)
		ld (Ayt_PatternSize),a		; Set Pattern Size
		push iy
		pop hl
		ld (Ayt_MusicCnt),hl		; Ptr on Var Counter music
		ld (Ayt_MusicCntPtr),hl
		ld (Ayt_MusicCntPtrInit),hl
		inc hl
		ld (Ayt_FirstSeq),hl		; Ptr on Var 1st Seq
		ld (Ayt_SeqPatternPtr_Upd),hl	; Ptr on curr sequence ptr
		ld (Ayt_FirstSeqInitPtr),hl
		inc hl
		inc hl
		ld (Ayt_PatternIdx),hl		; Ptr on Var Idx on pattern
		ld (Ayt_PatCountPtr1),hl	; update of Idx in pattern in B3
		ld (Ayt_PatCountPtr2),hl	; update of Idx in pattern in B3
	ifnot PlayerAccessByJP
		inc hl
		inc hl
		ld (Ayt_PtrSaveSP),hl		; Ptr on Var SP Backup
		ld (Ayt_ReloadSP),hl
	endif		
		inc hl				; define dma list address
		inc hl
		bit 0,l				; on even address
		jr z,AYT_DMAEvenAddr
		inc hl				; no set to even
AYT_DMAEvenAddr		
		ld a,l
		ld (Ayt_SendAY_PtR13),a
		inc l
		ld (AYT_DMAAddrInit),hl		; Fix Address for init routine
		inc l
		ld (Ayt_DmaListPtr),hl
		ld a,l				; 2nd reg (1st if R13 not played)
		ld (Ayt_SendAY_Ptr1st),a
		;;-------------------------------------------------------------------------------------------------------------------------------
		;; Save asic state settings
		;;-------------------------------------------------------------------------------------------------------------------------------
		ld a,c
		ld (Ayt_Prm_AsicState_Out),a	; io page asic state expected at exit point
		ld a,b				; io page asic state at entry point
		;;-------------------------------------------------------------------------------------------------------------------------------
		;; In AYT file , relocate sequence list ptr on rxx data. (absolute address)
		;; In >> ix=Ptr on AYT File
		;;-------------------------------------------------------------------------------------------------------------------------------
		push ix
		pop bc				; bc=Ptr on start of AYT file
		;
		;;-------------------------------------------------------------------------------------------------------------------------------
		;; If AsicIoPage is mapped at player entry, then AsicIoPage needs to be off if the AYT file is in the Asic area space
		;;-------------------------------------------------------------------------------------------------------------------------------
		ld l,(ix+AYT_OFS_ListInit)	; Offset on Init List 
		ld h,(ix+AYT_OFS_ListInit+1)
		add hl,bc			; Ptr on Ay Init List 
		ld (Ayt_PtrInitList),hl		; In Block 4 if created
		;------------------------------------
		or a
		jr z,Ayt_End_AsicInIsOff	; Asic in is off, no problem for AYT File. Update AsicIOState=0 (off)
		ld a,#3f
		cp b				; ayt file start adress > #3fff
		jr c,Ayt_TstF_AreaAyt		; additionnal test to do
		cp h				; ayt file end address <= #3fff
		jr nc,Ayt_TstF_AreaSafe		; AYT file is not in asic io space
Ayt_TstF_AreaAyt 				; AYT file start or end address >=4000		
		ld a,b				; Is start address >=#8000 ?
		cp #80				; 
		jr nc,Ayt_TstF_AreaSafe		; Yes, no in asic io space
		ld hl,Ayt_Player_B0_Start		; Copy code for IoPage Off
		push bc				; AYT file is in Asic io space > asic need to be disconnected
		ld bc,Ayt_Player_B0_End-Ayt_Player_B0_Start
		ldir 
		pop bc
Ayt_TstF_AreaSafe
		ld a,1				; Cf flag =1 if Asic disconnected >> AsicIOState=0 (off)
		sbc a,0				; If asic stay connected (ayt not in io area), AsicIOState=1 (on)
Ayt_End_AsicInIsOff
		ld (AsicIOPageConnect),a	; State of Asic io page (0=off, <>0=on)

		push de				; save curr ptr on player code
		;
		ld l,(ix+AYT_OFS_LoopSeq)	; Offset of Loop Sequence
		ld h,(ix+AYT_OFS_LoopSeq+1)
		add hl,bc
		ld (Ayt_LoopSeq),hl		; Set Loop Sequence
		; 
		ld l,(ix+AYT_OFS_FirstSeq)	; read offset of first seq from start
		ld h,(ix+AYT_OFS_FirstSeq+1)
		add hl,bc			; Ptr on first sequence
		ld (Ayt_FirstSeqValue),hl
		push hl
		pop iy				; IY ptr on first sequence of pattern ptr by reg
		;
		ld hl,AYT_SIZE_HEADER
		add hl,bc
		ld b,h
		ld c,l
		;
		ld e,(ix+AYT_OFS_NbPatternPtr)
		ld d,(ix+AYT_OFS_NbPatternPtr+1); Nb of Pattern Ptr in all Sequence of AYT file
Ayt_PtrFix_b1
		ld l,(iy+0)
		ld h,(iy+1)			; Read Offset Seq
		add hl,bc			; Absolute Address for Seq Ptr on Rxx
		ld (iy+0),l
		ld (iy+1),h
		inc iy				; Next Seq Ptr rxx+1
		inc iy
		dec de
		ld a,d
		or e
		jr nz,Ayt_PtrFix_b1		; loop all sequence
		pop de				; restore current ptr on player code
		;;
		;----------------------------------------------------------------
		; copy updated block 1 of player in ram
		;----------------------------------------------------------------
		;
		ld hl,Ayt_PLayer_B1_Start
		ld bc,Ayt_Player_B1_End-Ayt_Player_B1_Start
		ldir
		;----------------------------------------------------------------
		; Count Active regs (a=0 here)
		;----------------------------------------------------------------
		;
		ld b,13
		ld l,(ix+AYT_OFS_ActiveRegs)
		ld h,(ix+AYT_OFS_ActiveRegs+1)	; bit 15, 14, 13, ... of HL are active ay reg 0, 1, 2, 3... if 1
		ld (Ayt_Active_Regs),hl
Ayt_Count_ActiveRegs
		add hl,hl			; Is AyReg active ?
		adc a,c
		djnz Ayt_Count_ActiveRegs
		;----------------------------------------------------------------
		; copy n active "update list" of ay reg in dma list (without r13)
		;----------------------------------------------------------------
Ayt_Build_Nreg
		ld hl,Ayt_Player_B2_Start
		ld c,Ayt_Player_B2_End-Ayt_Player_B2_Start
		ldir
		dec a
		jr nz,Ayt_Build_Nreg
		dec de
		dec de				; forget the 2 last inc e
		;
		;----------------------------------------------------------------
		; Copy 1st bloc of last part for R13 & Loop control
		;----------------------------------------------------------------
		;
		ld hl,Ayt_Player_B3_Start
		push de
		pop iy
		ld c,AYT_B3_SIZE
		ldir
		;----------------------------------------------------------------
		; Copy code for asic io page connection (depending of io current state
		; and state when exiting player)
		;----------------------------------------------------------------
AsicIOPageConnect equ $+1
		ld a,0						; State of io asic page (0=off/1=on)
		or a
		jr z,Ayt_Asic_IsOff				; Br if Page off 
		ld hl,Ayt_Player_B6b_Start			; if Page already On, no need to reconnect
		ld c,Ayt_Player_B6_EndA-Ayt_Player_B6b_Start	; Copy block without instr BC/OUT. Asic IS On
		ldir
Ayt_Prm_AsicState_Out equ $+1
		ld a,0
		or a
		ld a,9						; No add instruction for io asic (bc,out,c,out==9) 
		jr nz,Ayt_Asic_MIO_End				; Asic io page stay On
								; If Asic io page must be off at exit
		ld hl,Ayt_Player_B7_Start			; Copy opcodes asic off for exit (bc full)
		ld c,Ayt_Player_B7_End-Ayt_Player_B7_Start
		ld a,4						; a=Delta bytes for jr between B3 & B5
		ldir
		jr Ayt_Asic_MIO_End
Ayt_Asic_IsOff
		ld hl,Ayt_Player_B6a_Start			; Asic if OFF. Need to be connected for DMA ctrl access
		ld a,(Ayt_Prm_AsicState_Out)			; what is io asic page expected at exit
		or a
		ld a,4						; Delta jr for asic io page on at exit
		ld c,Ayt_Player_B6_EndA-Ayt_Player_B6a_Start	; Copy of instr to connect asic (bc/out) and nothing more
		jr nz,Ayt_AsicState_EndG
								; If Asic io page must be OFF at exit
		ld c,Ayt_Player_B6_EndB-Ayt_Player_B6a_Start	; Copy of instr to connect asic (bc/out) and disconnect asic for exit (c/out)
		xor a						; delta byte=0 (code is conform to asm compilation)
Ayt_AsicState_EndG	
		ldir
Ayt_Asic_MIO_End
		;----------------------------------------------------------------
		; copy bloc 5 (second part of ratatouille)
		;----------------------------------------------------------------
		;
		ld hl,Ayt_Player_B5_Start
		ld bc,Ayt_Player_B5_End-Ayt_Player_B5_Start
		push de
		pop ix						; ix=ptr on B5 start
		ldir
		;----------------------------------------------------------------
		; DE=Ptr of 1st free byte after player.
		;----------------------------------------------------------------
		ld hl,Ayt_Player_B4_Start
		ld bc,AYT_B4_SIZE		; block 4 created
		push de
		ldir				; de on next free freebyte
		;
		;----------------------------------------------------------------
		; Correct relatives jump b5 to b3
		;----------------------------------------------------------------
		;
		ld b,a
		add a,(ix+OFS_B5_Jrel1)			; Correct relative jump
		ld (ix+OFS_B5_Jrel1),a
		ld a,b
		add a,(ix+OFS_B5_Jrel2)			
		ld (ix+OFS_B5_Jrel2),a
		ld a,b
		add a,(ix+OFS_B5_Jrel3)			
		ld (ix+OFS_B5_Jrel3),a
		;----------------------------------------------------------------
		; Correct relatives jump b3 to b5
		;----------------------------------------------------------------
		;
		ld a,b
		neg
		ld b,a
		add a,(iy+OFS_B3_Jrel1)
		ld (iy+OFS_B3_Jrel1),a
		ld a,b
		add a,(iy+OFS_B3_Jrel2)
		ld (iy+OFS_B3_Jrel2),a
		ld a,b
		add a,(iy+OFS_B3_Jrel3)
		ld (iy+OFS_B3_Jrel3),a
		; 
		;----------------------------------------------------------------
		pop hl				; reload ptr routine init
		;----------------------------------------------------------------
		ret

;===============================================================================================================================================
; Raw code template for the constructor
;===============================================================================================================================================
;-----------------------------------------------------------------------------------------------------------------------------------------------
Ayt_Player_B0_Start
		ld bc,#7f00+AYT_AsicPage_Off	; If AYT file is in Asic Io Page AND Asic IO Page is mapped, need to switch off Io Page
		out (c),c
Ayt_Player_B0_End
 
;-----------------------------------------------------------------------------------------------------------------------------------------------
Ayt_Player_B1_Start
	ifnot PlayerAccessByJP
Ayt_PtrSaveSP	equ $+2
		ld (0),sp		; 6 nop SP is saved if player is "called"
	endif		
Ayt_FirstSeq	equ $+2
		ld sp,(0)
Ayt_DmaListPtr	equ $+1
		ld de,0			; Ptr on DMA AY List from 0
Ayt_PatternIdx	equ $+2
		ld bc,(0)
Ayt_Player_B1_End
;-----------------------------------------------------------------------------------------------------------------------------------------------
Ayt_Player_B2_Start	
		pop hl			; Get Pattern Ptr
		add hl,bc		; + offset in Pattern
		ld a,(hl)		; read data register
		ld (de),a		; update dma list
		inc e			; go to next register 
		inc e			; 
Ayt_Player_B2_End
;-----------------------------------------------------------------------------------------------------------------------------------------------
Ayt_Player_B3_Start
		pop hl			; Get Pattern Ptr for r13
		add hl,bc		; + offset in Pattern
		bit 7,(hl)		; is it a valid reg ?
Ayt_B3ToB5_Jr1 equ $+1 
		jr z,Ayt_SendAY_r13	; 03/02/02/02/03/02 
Ayt_SendAY_PtR1st equ $+1
		ld e,0			; 00/02/02/02/00/02
		bit 6,(hl)		; 00/03/03/03/00/03 is it the end of music
Ayt_B3ToB5_Jr2 equ $+1
		jr nz,Ayt_Player_r13end	; 00/03/02/02/00/03
Ayt_MusicCnt equ $+1
		ld a,(0)		; 00/00/04/04/00/00 loop counter ****
		dec a			; 00/00/01/01/00/00
Ayt_B3ToB5_Jr3 equ $+1
		jr z,Ayt_MusicEnd	; 00/00/03/02/00/00 loop finished ?
Ayt_MusicCntPtr equ $+1
		ld (0),a		; 00/00/00/04/00/00 no, loop counter upd
Ayt_LoopSeq  equ $+1
		ld sp,0			; 00/00/00/03/00/00 Ptr on sequence loop
Ayt_SeqPatternPtr_Upd equ $+2		; !!! Critical on 4th branch !!!
Ayt_NewPattern
		ld (0),sp		; 06/06/00/06/00/00 update ptr of seq on patterns
		xor a			; 01/01/00/01/00/00 offset all pattern to 0
Ayt_SeqPat
Ayt_PatCountPtr2 equ $+1		; 
		ld (0),a		; 04/04/00/04/04/04 update offset on patterns
Ayt_PlayerExit				
Ayt_Player_B3_End
;-----------------------------------------------------------------------------------------------------------------------------------------------
Ayt_Player_B6a_Start
		ld bc,#7f00+AYT_AsicPage_On
		out (c),c
Ayt_Player_B6b_Start
		ld (PlayerDMAUsed_SAR),de ; update Ptr DMA Liste 
		ld a,(AYT_Asic_DCSR)	  ; read dcsr (active dma channels)
		or PlayerDMAUsed_DCSRMask ; activate selected dma
		ld (AYT_Asic_DCSR),a	  ; update dcsr
Ayt_Player_B6_EndA
		ld c,AYT_AsicPage_Off
		out (c),c
Ayt_Player_B6_EndB
;-----------------------------------------------------------------------------------------------------------------------------------------------
Ayt_Player_B5_Start
	if PlayerAccessByJP
Ayt_ExitPtr01	equ $+1
		jp 0 			; 3 exit from player 
	else	
Ayt_ReloadSP	equ $+2
		ld sp,(0)		; 6 nop Player was called , SP is restored
		ret			; 3 and return to main code
	endif
Ayt_MusicEnd				; Player on mute
					; 
		ex (sp),hl		; 00/00/06/00/00/00
		ex (sp),hl		; 00/00/06/00/00/00
		cp (hl)			; 00/00/02/00/00/00
Ayt_B5ToB3_Jr1 equ $+1
		jr Ayt_PlayerExit	; 00/00/03/00/00/00 
		;------------------------
Ayt_SendAY_r13				;
Ayt_SendAY_PtR13 equ $+1
		ld e,0			; 02/00/00/00/02/00
		ld a,(hl)		; 02/00/00/00/02/00
		ld (de),a		; 02/00/00/00/02/00
		nop			; 01/00/00/00/01/00		
Ayt_Player_r13end
					;------------------
Ayt_PatCountPtr1 equ $+1
		ld a,(0)		; 04/04/00/00/04/04 Get Pattern offset
		jr $+2			; 03/03/00/00/03/03
		inc a			; 01/01/00/00/01/01 Offset +1
Ayt_PatternSize	equ $+1
		cp  0			; 02/02/00/00/02/02 Pattern completed ?
Ayt_B5ToB3_Jr2 equ $+1
		jr z,Ayt_NewPattern	; 03/03/00/00/02/02 
Ayt_PatternCur				;  
		cp (hl)			; 00/00/00/00/02/02
		cp (hl)			; 00/00/00/00/02/02
		nop			; 00/00/00/00/01/01
Ayt_B5ToB3_Jr3 equ $+1
		jr Ayt_SeqPat		; 00/00/00/00/03/03 
					;-------------------
					; 34/34/34/34/34/34
Ayt_Player_B5_End
;-----------------------------------------------------------------------------------------------------------------------------------------------
Ayt_Player_B7_Start
		ld bc,#7f00+AYT_AsicPage_Off
		out (c),c
Ayt_Player_B7_End
;-----------------------------------------------------------------------------------------------------------------------------------------------
; Init of non active AY reg, setting variables & Dma List in Ram
;-----------------------------------------------------------------------------------------------------------------------------------------------
Ayt_Player_B4_Start
AYT_DMAAddrInit	equ $+1
		ld hl,0			; DMA Address to init
		ld a,13			; r13 @ start of dma list (easiest to skip)
		ld b,a			; counter to test all active registers
		ld (hl),a		; update dma reg
		inc l			; bc=ptr on first AY reg data
		ex de,hl
Ayt_Active_Regs equ $+1
		ld hl,0			; bit 15, 14, 13, ... of HL are active ay reg 0, 1, 2, 3... if 1
		xor a			; ay countet after r13
		ld c,a			; counter on ay reg created
AYT_BS_DMAListB
		add hl,hl		; Is AyReg active ?
		jr nc,AYT_BS_NotActive	; Skip if reg not active 
		inc c			; created dma send ++ (DMA_AY_PLAY)
		inc e
		ld (de),a		; Set reg number
		inc e
AYT_BS_NotActive
		inc a			; Ay counter++
		djnz AYT_BS_DMAListB
		ld a,#20		; AY List finished by DMA_AY_STOP
		ld (de),a
		inc e
		add a,a
		ld (de),a

Ayt_MusicCntValue equ $+1
		ld a,0
Ayt_MusicCntPtrInit	equ $+1
		ld (0),a		; Init Music Loop counter
Ayt_FirstSeqValue equ $+1
		ld hl,0
Ayt_FirstSeqInitPtr equ $+1
		ld (0),hl
		ld bc,#f680		; ppi port c mode data
		exx
		ld b,#f4		; ppi port a
		ld a,#e6		; Port C (printer on)
		out (#ff),a		; Select Ay Idx Reg (1st time)
Ayt_PtrInitList	equ $+1
		ld hl,0
Ayt_InitReg_Loop
		ld c,(hl)		; get register
		bit 7,c			; End list of init ay reg
		ret nz			; yes
		inc hl			; no ptr on data
		out (c),c 		; Port A, select No Reg AY
		ld b,a			; Port C (F6)
		db #ed,#71		; out (c),0 / valid
		dec b			; F5>>F4 (port A) via OUTI
		outi			; Send to Data Ay 
		exx
		out (c),c		; Port C, mode data
		out (#ff),a		; Port C, mode IdxReg+Valid
		exx
		jr Ayt_InitReg_Loop	; next reg
Ayt_Player_B4_End
;-----------------------------------------------------------------------------------------------------------------------------------------------
Ayt_Builder_End
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

