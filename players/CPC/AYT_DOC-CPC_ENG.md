![Image Presentation CPC](../../images/AYTPRES1OLD.jpg)

## Calling Ayt_Builder on CPC 464/664/6128

		ld ix,AYT_File		; Address of the AYT file
		ld de,AYT_Player	; Address where the player will be generated
		ld a,2			; Number of times to play the music
		call Ayt_Builder

After the *Ayt_Builder* function returns:
- The **DE** register contains the address of the first free byte after the *player*.
- The **HL** register contains the number of microseconds (NOPs) consumed by the *player* call.

To play the music, the *player* must be called at the correct frequency.  
Most tracks require the *player* to be called periodically, typically 50 times per second.  
The **AYT** file header specifies this period.  

It is very **important to ensure that no interrupt occurs during the player call**. If you are not familiar with the **Z80A** interrupt system, you can use the **DI** instruction before calling the *player*.

		call AYT_Player	; Execute the player to play the music

### Compilation Option
#### PlayerAccessByJP
If the **PlayerAccessByJP** option is set to 1, you must also provide the return address for the *player*.

		ld ix,AYT_File			; Address of the AYT file
		ld de,AYT_Player		; Address where the player will be generated
		ld hl,AYT_Player_Ret		; Address to return to after player execution
		ld a,2				; Number of times to play the music
		call Ayt_Builder

The return address is placed immediately after the *player* call:

			jp AYT_Player	; Execute the player
	AYT_Player_Ret			; Player return address

Unless you want to boast about saving **11 µseconds**, it is recommended to leave this option at 0. This also avoids the need to save and restore the stack pointer.

Refer to the performance table at the end of the document to see CPU usage and the size of the generated *player*.

***Notes:***
- The *player* mutes the sound circuit once the loop count is reached.
- Registers that require initialization are set automatically during the first call.
- Loops occur exactly where specified by the **YM** file.
- Whether looping or muting, the *player* maintains a constant CPU usage per call.

### Player Call Frequency
The *player* is usually called in sync with the screen refresh rate, which is 50 Hz.  
This information is available in the **AYT** file header.  
On CPC 464/664/6128, the 50 Hz signal is generated by the **CRTC 6845**, which signals Vsync via the **PPI 8255**.  
You can test the Vsync signal using the following code:

           ld b,#f5        ; Select port B of the PPI 8255
    Wait_Vsync
            rra             ; Rotate right to check bit 0
            jr nc,Wait_Vsync     ; Wait until bit 0 is set

Interrupts on the CPC also allow precise synchronization.

### Pre-Building the Player
It is entirely possible to ***pre-build*** the *player*.

Use *Ayt_Builder* to create the *player* and initialize the **AYT** file in advance.  
Simply save the generated *player* and the updated **AYT** file after the function call.

You can then integrate both at the predefined addresses used during the *Ayt_Builder* call.

### Performance

Execution time and memory usage of the *player* depend on several factors:
- Number of active registers detected by the compressor (up to 14).
- *Calling method* of the *player* (**CALL** or **JP**) across all platforms.

The *calling method* defines how the *player* is called in Z80A.  
It is a compilation option for the *builder*:
- If **CALL**, the program must use the Z80A **"CALL"** instruction to invoke the *player*.
- If **JP**, the program uses the Z80A **"JP"** instruction.  
  - The *player* does not save the **SP** register, saving **11 NOPs** (on **CPC**).
  - This option is useful only if the program calling the *player* would modify **SP** anyway.
  - Otherwise, it has these drawbacks:
    - The *builder* must be called every time the return address changes:
      - This often occurs during *development*, requiring the *builder* to be in RAM.
      - It can also occur if the *player* is called from multiple locations.
    - The stack pointer must be restored, as any push or call would corrupt **AYT** data.

The table below shows *player* performance for 10–14 active registers for both calling methods.
The player size includes the register initialization routine, which can be retrieved after the first call to the *player*.
This initialization routine accounts for **57 bytes** at the end of the player.
The CPU usage can vary from 1 to 3 NOP instructions depending on the active registers.

| Calling Method | Active Registers | CPU (NOPs) | Player Size (bytes) | Builder Size (bytes) |
| :-----------: | :--------------: | :---------: | :----------------: | :----------------: |
| JP            | 10               | 360         | 269           | 476            |
| JP            | 11               | 391         | 286           | 476            |        
| JP            | 12               | 422         | 303           | 476            |        
| JP            | 13               | 452         | 320           | 476            |        
| JP            | 14               | 481         | 337           | 476            |        
| CALL          | 10               | 371         | 274           | 490            |
| CALL          | 11               | 402         | 291           | 490            |
| CALL          | 12               | 433         | 308           | 490            |
| CALL          | 13               | 463         | 325           | 490            |
| CALL          | 14               | 492         | 342           | 490            |



