![Image Presentation CPC](../../images/AYTPRES1OLD.jpg)

## WARNING!

### This document concerns the use of the ROM version of Ayt_Builder

For using the *player* in **ROM**, a specific version of *AYT_Builder* has been created.

Its usage and parameters are significantly different from the version that runs in **RAM**.

If you plan to use the player in **RAM**, I recommend using the standard version because it takes up less space and is more **CPU** efficient.

On the CPC, **ROMs** can be activated at addresses **0x0000-0x3FFF** and/or **0xC000-0xFFFF**.
The generated player will use a buffer passed as a parameter to *Ayt_Builder* for its variables.

## Calling Ayt_Builder on CPC 464/664/6128

		ld ix,AYT_File		; Address of the AYT file
		ld de,AYT_Player	; Address where the player will be generated
		ld iy,AYT_Buffer ; Address of a Buffer in RAM
		ld a,2			; Number of times to play the music
		call Ayt_Builder

The RAM buffer must have the following size:
		AYT_Buffer ds 7,0 ; 7 bytes set to 0 when **PlayAccessByJP==0**
		or
		AYT_Buffer ds 5,0 ; 5 bytes set to 0 when **PlayAccessByJP==1**

The address of this buffer must not be located in the space where the ROM containing the *player* will be connected.

After the *Ayt_Builder* function returns:
- The **DE** register contains the address of the first free byte after the *player*.
- The **HL** register contains the number of microseconds (NOPs) consumed by the *player* call.
- The **BC** register contains the address that must be called to initialize the *player*

To play the music, the *player* must be called at the correct frequency.  
Most tracks require the *player* to be called periodically, typically 50 times per second.  
The **AYT** file header specifies this period.  

### Compilation Option
#### PlayerAccessByJP
If the **PlayerAccessByJP** option is set to 1, you must also provide the return address for the *player*.

		ld ix,AYT_File			; Address of the AYT file
		ld iy,AYT_Buffer ; Address of a Buffer in RAM
		ld de,AYT_Player		; Address where the player will be generated
		ld hl,AYT_Player_Ret		; Address to return to after player execution
		ld a,2				; Number of times to play the music
		call Ayt_Builder

The return address is placed immediately after the *player* call:

			jp AYT_Player	; Execute the player
	AYT_Player_Ret			; Player return address

Unless you want to boast about saving **11 µseconds**, it is recommended to leave this option at 0. This also avoids the need to save and restore the stack pointer.

### Initialization
If the compressor identifies *inactive* registers, they are excluded from the **AYT** data but still require prior initialization.

The player in **ROM** uses variables located in **RAM**, and the initialization routine is responsible for updating these variables.

Therefore, calling the initialization routine is **mandatory** only once before calling the *player* periodically.

Here is the process to implement to call an initialization routine (PlayerAccessByJP=0):

		ld ix,AYT_File` ; AYT_File is the address where the AYT file is located
		ld iy,AYT_Buffer` ; AYT_Buffer is the address of a buffer in RAM
		ld de,AYT_Player` ; AYT_Player is the address where the player will be built
		ld a,2` ; A indicates how many times the music will be played.
		call Ayt_Builder
		ld(InitPlayer),bc ; Updating the initialization routine
		...
		...
		InitPlayer equ $+1
		call 0 ; After the update, CALL will be on the initialization routine

It is very **important to ensure that no interrupt occurs during the player call**. If you are not familiar with the **Z80A** interrupt system, you can use the **DI** instruction before calling the *player*.

		call AYT_Player	; Execute the player to play the music

Refer to the performance table at the end of the document to see CPU usage and the size of the generated *player*.

***Notes:***
- The *player* mutes the sound circuit once the loop count is reached.
- Registers that require initialization are set automatically during the first call.
- Loops occur exactly where specified by the **YM** file.
- Whether looping or muting, the *player* maintains a constant CPU usage per call.

### Player Call Frequency
The *player* is usually called in sync with the screen refresh rate, which is 50 Hz.  
This information is available in the **AYT** file header.  
On CPC 464/664/6128, the 50 Hz signal is generated by the **CRTC 6845**, which signals Vsync via the **PPI 8255**.  
You can test the Vsync signal using the following code:

           ld b,#f5        ; Select port B of the PPI 8255
    Wait_Vsync
            rra             ; Rotate right to check bit 0
            jr nc,Wait_Vsync     ; Wait until bit 0 is set

Interrupts on the CPC also allow precise synchronization.

### Pre-Building the Player
It is entirely possible to ***pre-build*** the *player*.

Use *Ayt_Builder* to create the *player* and initialize the **AYT** file in advance.  
Simply save the generated *player* and the updated **AYT** file after the function call.

You can then integrate both at the predefined addresses used during the *Ayt_Builder* call.

### Performance

Execution time and memory usage of the *player* depend on several factors:
- Number of active registers detected by the compressor (up to 14).
- *Calling method* of the *player* (**CALL** or **JP**) across all platforms.

The *calling method* defines how the *player* is called in Z80A.  
It is a compilation option for the *builder*:
- If **CALL**, the program must use the Z80A **"CALL"** instruction to invoke the *player*.
- If **JP**, the program uses the Z80A **"JP"** instruction.  
  - The *player* does not save the **SP** register, saving **11 NOPs** (on **CPC**).
  - This option is useful only if the program calling the *player* would modify **SP** anyway.
  - Otherwise, it has these drawbacks:
    - The *builder* must be called every time the return address changes:
      - This often occurs during *development*, requiring the *builder* to be in RAM.
      - It can also occur if the *player* is called from multiple locations.
    - The stack pointer must be restored, as any push or call would corrupt **AYT** data.

The table below shows *player* performance for 10–14 active registers for both calling methods.
The player size accounts for the register initialization routine.
The CPU usage can vary from 1 to 3 NOP instructions depending on the active registers.

| Calling Method | Active Registers | CPU (NOPs) | Player Size (bytes) | Builder Size (bytes) |
| :-----------: | :--------------: | :---------: | :----------------: | :----------------: |
| JP            | 10               | 366         | 299           | 386            |
| JP            | 11               | 397         | 315           | 386            |        
| JP            | 12               | 428         | 331           | 386            |        
| JP            | 13               | 458         | 347           | 386            |        
| JP            | 14               | 487         | 363           | 386            |        
| CALL          | 10               | 380         | 305           | 397            |
| CALL          | 11               | 411         | 321           | 397            |
| CALL          | 12               | 442         | 337           | 397            |
| CALL          | 13               | 472         | 353           | 397            |
| CALL          | 14               | 501         | 369           | 397            |





